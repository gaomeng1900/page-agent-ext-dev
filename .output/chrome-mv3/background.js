var background=(function(){"use strict";function defineBackground(t){return t==null||typeof t=="function"?{main:t}:t}const ANSI_BACKGROUND_OFFSET=10,wrapAnsi16=(t=0)=>e=>`\x1B[${e+t}m`,wrapAnsi256=(t=0)=>e=>`\x1B[${38+t};5;${e}m`,wrapAnsi16m=(t=0)=>(e,s,o)=>`\x1B[${38+t};2;${e};${s};${o}m`,styles$1={modifier:{reset:[0,0],bold:[1,22],dim:[2,22],italic:[3,23],underline:[4,24],overline:[53,55],inverse:[7,27],hidden:[8,28],strikethrough:[9,29]},color:{black:[30,39],red:[31,39],green:[32,39],yellow:[33,39],blue:[34,39],magenta:[35,39],cyan:[36,39],white:[37,39],blackBright:[90,39],gray:[90,39],grey:[90,39],redBright:[91,39],greenBright:[92,39],yellowBright:[93,39],blueBright:[94,39],magentaBright:[95,39],cyanBright:[96,39],whiteBright:[97,39]},bgColor:{bgBlack:[40,49],bgRed:[41,49],bgGreen:[42,49],bgYellow:[43,49],bgBlue:[44,49],bgMagenta:[45,49],bgCyan:[46,49],bgWhite:[47,49],bgBlackBright:[100,49],bgGray:[100,49],bgGrey:[100,49],bgRedBright:[101,49],bgGreenBright:[102,49],bgYellowBright:[103,49],bgBlueBright:[104,49],bgMagentaBright:[105,49],bgCyanBright:[106,49],bgWhiteBright:[107,49]}};Object.keys(styles$1.modifier);const foregroundColorNames=Object.keys(styles$1.color),backgroundColorNames=Object.keys(styles$1.bgColor);[...foregroundColorNames,...backgroundColorNames];function assembleStyles(){const t=new Map;for(const[e,s]of Object.entries(styles$1)){for(const[o,r]of Object.entries(s))styles$1[o]={open:`\x1B[${r[0]}m`,close:`\x1B[${r[1]}m`},s[o]=styles$1[o],t.set(r[0],r[1]);Object.defineProperty(styles$1,e,{value:s,enumerable:!1})}return Object.defineProperty(styles$1,"codes",{value:t,enumerable:!1}),styles$1.color.close="\x1B[39m",styles$1.bgColor.close="\x1B[49m",styles$1.color.ansi=wrapAnsi16(),styles$1.color.ansi256=wrapAnsi256(),styles$1.color.ansi16m=wrapAnsi16m(),styles$1.bgColor.ansi=wrapAnsi16(ANSI_BACKGROUND_OFFSET),styles$1.bgColor.ansi256=wrapAnsi256(ANSI_BACKGROUND_OFFSET),styles$1.bgColor.ansi16m=wrapAnsi16m(ANSI_BACKGROUND_OFFSET),Object.defineProperties(styles$1,{rgbToAnsi256:{value(e,s,o){return e===s&&s===o?e<8?16:e>248?231:Math.round((e-8)/247*24)+232:16+36*Math.round(e/255*5)+6*Math.round(s/255*5)+Math.round(o/255*5)},enumerable:!1},hexToRgb:{value(e){const s=/[a-f\d]{6}|[a-f\d]{3}/i.exec(e.toString(16));if(!s)return[0,0,0];let[o]=s;o.length===3&&(o=[...o].map(n=>n+n).join(""));const r=Number.parseInt(o,16);return[r>>16&255,r>>8&255,r&255]},enumerable:!1},hexToAnsi256:{value:e=>styles$1.rgbToAnsi256(...styles$1.hexToRgb(e)),enumerable:!1},ansi256ToAnsi:{value(e){if(e<8)return 30+e;if(e<16)return 90+(e-8);let s,o,r;if(e>=232)s=((e-232)*10+8)/255,o=s,r=s;else{e-=16;const a=e%36;s=Math.floor(e/36)/5,o=Math.floor(a/6)/5,r=a%6/5}const n=Math.max(s,o,r)*2;if(n===0)return 30;let i=30+(Math.round(r)<<2|Math.round(o)<<1|Math.round(s));return n===2&&(i+=60),i},enumerable:!1},rgbToAnsi:{value:(e,s,o)=>styles$1.ansi256ToAnsi(styles$1.rgbToAnsi256(e,s,o)),enumerable:!1},hexToAnsi:{value:e=>styles$1.ansi256ToAnsi(styles$1.hexToAnsi256(e)),enumerable:!1}}),styles$1}const ansiStyles=assembleStyles(),level=(()=>{if(!("navigator"in globalThis))return 0;if(globalThis.navigator.userAgentData){const t=navigator.userAgentData.brands.find(({brand:e})=>e==="Chromium");if(t&&t.version>93)return 3}return/\b(Chrome|Chromium)\//.test(globalThis.navigator.userAgent)?1:0})(),colorSupport=level!==0&&{level},supportsColor={stdout:colorSupport,stderr:colorSupport};function stringReplaceAll(t,e,s){let o=t.indexOf(e);if(o===-1)return t;const r=e.length;let n=0,i="";do i+=t.slice(n,o)+e+s,n=o+r,o=t.indexOf(e,n);while(o!==-1);return i+=t.slice(n),i}function stringEncaseCRLFWithFirstIndex(t,e,s,o){let r=0,n="";do{const i=t[o-1]==="\r";n+=t.slice(r,i?o-1:o)+e+(i?`\r
`:`
`)+s,r=o+1,o=t.indexOf(`
`,r)}while(o!==-1);return n+=t.slice(r),n}const{stdout:stdoutColor,stderr:stderrColor}=supportsColor,GENERATOR=Symbol("GENERATOR"),STYLER=Symbol("STYLER"),IS_EMPTY=Symbol("IS_EMPTY"),levelMapping=["ansi","ansi","ansi256","ansi16m"],styles=Object.create(null),applyOptions=(t,e={})=>{if(e.level&&!(Number.isInteger(e.level)&&e.level>=0&&e.level<=3))throw new Error("The `level` option should be an integer from 0 to 3");const s=stdoutColor?stdoutColor.level:0;t.level=e.level===void 0?s:e.level},chalkFactory=t=>{const e=(...s)=>s.join(" ");return applyOptions(e,t),Object.setPrototypeOf(e,createChalk.prototype),e};function createChalk(t){return chalkFactory(t)}Object.setPrototypeOf(createChalk.prototype,Function.prototype);for(const[t,e]of Object.entries(ansiStyles))styles[t]={get(){const s=createBuilder(this,createStyler(e.open,e.close,this[STYLER]),this[IS_EMPTY]);return Object.defineProperty(this,t,{value:s}),s}};styles.visible={get(){const t=createBuilder(this,this[STYLER],!0);return Object.defineProperty(this,"visible",{value:t}),t}};const getModelAnsi=(t,e,s,...o)=>t==="rgb"?e==="ansi16m"?ansiStyles[s].ansi16m(...o):e==="ansi256"?ansiStyles[s].ansi256(ansiStyles.rgbToAnsi256(...o)):ansiStyles[s].ansi(ansiStyles.rgbToAnsi(...o)):t==="hex"?getModelAnsi("rgb",e,s,...ansiStyles.hexToRgb(...o)):ansiStyles[s][t](...o),usedModels=["rgb","hex","ansi256"];for(const t of usedModels){styles[t]={get(){const{level:s}=this;return function(...o){const r=createStyler(getModelAnsi(t,levelMapping[s],"color",...o),ansiStyles.color.close,this[STYLER]);return createBuilder(this,r,this[IS_EMPTY])}}};const e="bg"+t[0].toUpperCase()+t.slice(1);styles[e]={get(){const{level:s}=this;return function(...o){const r=createStyler(getModelAnsi(t,levelMapping[s],"bgColor",...o),ansiStyles.bgColor.close,this[STYLER]);return createBuilder(this,r,this[IS_EMPTY])}}}}const proto=Object.defineProperties(()=>{},{...styles,level:{enumerable:!0,get(){return this[GENERATOR].level},set(t){this[GENERATOR].level=t}}}),createStyler=(t,e,s)=>{let o,r;return s===void 0?(o=t,r=e):(o=s.openAll+t,r=e+s.closeAll),{open:t,close:e,openAll:o,closeAll:r,parent:s}},createBuilder=(t,e,s)=>{const o=(...r)=>applyStyle(o,r.length===1?""+r[0]:r.join(" "));return Object.setPrototypeOf(o,proto),o[GENERATOR]=t,o[STYLER]=e,o[IS_EMPTY]=s,o},applyStyle=(t,e)=>{if(t.level<=0||!e)return t[IS_EMPTY]?"":e;let s=t[STYLER];if(s===void 0)return e;const{openAll:o,closeAll:r}=s;if(e.includes("\x1B"))for(;s!==void 0;)e=stringReplaceAll(e,s.close,s.open),s=s.parent;const n=e.indexOf(`
`);return n!==-1&&(e=stringEncaseCRLFWithFirstIndex(e,r,o,n)),o+e+r};Object.defineProperties(createChalk.prototype,styles);const chalk=createChalk();createChalk({level:stderrColor?stderrColor.level:0});class LLMClient{config;constructor(e){this.config=e}async chat(e,s,o){const n=`${this.config.baseURL||"https://api.openai.com/v1"}/chat/completions`,i={model:this.config.model,messages:e,temperature:.7,max_tokens:4096};s&&s.length>0&&(i.tools=s.map(c=>({type:"function",function:{name:c.name,description:c.description,parameters:c.parameters}})),o&&(i.tool_choice=o));const a=await fetch(n,{method:"POST",headers:{"Content-Type":"application/json",Authorization:`Bearer ${this.config.apiKey}`},body:JSON.stringify(i)});if(!a.ok){const c=await a.text();throw new Error(`LLM API error (${a.status}): ${c}`)}const l=await a.json();return{message:{role:"assistant",content:l.choices[0].message.content,tool_calls:l.choices[0].message.tool_calls},usage:l.usage}}static createVisionMessage(e,s){return{role:"user",content:[{type:"text",text:e},{type:"image_url",image_url:{url:s,detail:"high"}}]}}static createTextMessage(e,s){return{role:e,content:s}}static createToolMessage(e,s,o){return{role:"tool",content:o,tool_call_id:e,name:s}}}const openTabTool={name:"open_tab",description:"Open a new tab with the specified URL",parameters:{type:"object",properties:{url:{type:"string",description:"The URL to open. Must be a valid http/https URL."},active:{type:"boolean",description:"Whether to make the new tab active (focused). Default is true."}},required:["url"]}};async function openTab(t){try{return`âœ… Opened new tab (ID: ${(await chrome.tabs.create({url:t.url,active:t.active!==!1})).id}) with URL: ${t.url}`}catch(e){return`âŒ Failed to open tab: ${e.message}`}}const activeTabTool={name:"active_tab",description:"Switch to (activate/focus) a specific tab by ID",parameters:{type:"object",properties:{tabId:{type:"number",description:"The ID of the tab to activate"}},required:["tabId"]}};async function activeTab(t){try{await chrome.tabs.update(t.tabId,{active:!0});const e=await chrome.tabs.get(t.tabId);return`âœ… Activated tab (ID: ${t.tabId}): ${e.title}`}catch(e){return`âŒ Failed to activate tab: ${e.message}`}}const closeTabTool={name:"close_tab",description:"Close a specific tab by ID",parameters:{type:"object",properties:{tabId:{type:"number",description:"The ID of the tab to close"}},required:["tabId"]}};async function closeTab(t){try{return await chrome.tabs.remove(t.tabId),`âœ… Closed tab (ID: ${t.tabId})`}catch(e){return`âŒ Failed to close tab: ${e.message}`}}const reloadTabTool={name:"reload_tab",description:"Reload a specific tab",parameters:{type:"object",properties:{tabId:{type:"number",description:"The ID of the tab to reload. If not provided, reload the active tab."},bypassCache:{type:"boolean",description:"Whether to bypass the cache (hard reload). Default is false."}},required:[]}};async function reloadTab(t){try{let e=t.tabId;if(!e){const[s]=await chrome.tabs.query({active:!0,currentWindow:!0});if(!s?.id)return"âŒ No active tab found";e=s.id}return await chrome.tabs.reload(e,{bypassCache:t.bypassCache}),`âœ… Reloaded tab (ID: ${e})${t.bypassCache?" (bypassed cache)":""}`}catch(e){return`âŒ Failed to reload tab: ${e.message}`}}const scrollPageTool={name:"scroll_page",description:"Scroll the page in the specified direction",parameters:{type:"object",properties:{tabId:{type:"number",description:"The ID of the tab to scroll. If not provided, scroll the active tab."},direction:{type:"string",description:"Scroll direction",enum:["up","down","top","bottom"]},amount:{type:"number",description:'Scroll amount in pixels. Only used for "up" and "down". Default is one viewport height.'}},required:["direction"]}};async function scrollPage(args){try{let tabId=args.tabId;if(!tabId){const[t]=await chrome.tabs.query({active:!0,currentWindow:!0});if(!t?.id)return"âŒ No active tab found";tabId=t.id}const code=(()=>{switch(args.direction){case"up":return`window.scrollBy(0, -(${args.amount||"window.innerHeight"}))`;case"down":return`window.scrollBy(0, ${args.amount||"window.innerHeight"})`;case"top":return"window.scrollTo(0, 0)";case"bottom":return"window.scrollTo(0, document.body.scrollHeight)"}})();return await chrome.scripting.executeScript({target:{tabId},func:scrollCode=>{eval(scrollCode)},args:[code]}),`âœ… Scrolled ${args.direction} in tab (ID: ${tabId})`}catch(t){return`âŒ Failed to scroll: ${t.message}`}}const clickTool={name:"click",description:"Click an element on the page using CSS selector",parameters:{type:"object",properties:{tabId:{type:"number",description:"The ID of the tab. If not provided, use the active tab."},selector:{type:"string",description:`CSS selector of the element to click. Examples: "button.submit", "#login", "a[href='/about']"`},waitAfter:{type:"number",description:"Milliseconds to wait after clicking. Default is 500ms."}},required:["selector"]}};async function click(t){try{let e=t.tabId;if(!e){const[r]=await chrome.tabs.query({active:!0,currentWindow:!0});if(!r?.id)return"âŒ No active tab found";e=r.id}const o=(await chrome.scripting.executeScript({target:{tabId:e},func:(r,n)=>{const i=document.querySelector(r);return i?(i.click(),new Promise(a=>{setTimeout(()=>{a({success:!0,text:i.innerText?.slice(0,100)||i.tagName})},n)})):{success:!1,error:`Element not found: ${r}`}},args:[t.selector,t.waitAfter||500]}))[0]?.result;return o?.success?`âœ… Clicked element "${t.selector}" (text: "${o.text}") in tab (ID: ${e})`:`âŒ ${o?.error||"Click failed"}`}catch(e){return`âŒ Failed to click: ${e.message}`}}const keydownTool={name:"keydown",description:"Type text into a focused input field or send keyboard shortcuts",parameters:{type:"object",properties:{tabId:{type:"number",description:"The ID of the tab. If not provided, use the active tab."},selector:{type:"string",description:"CSS selector of the input element. If not provided, types into the currently focused element."},text:{type:"string",description:'Text to type. Use "\\n" for Enter key.'}},required:["text"]}};async function keydown(t){try{let e=t.tabId;if(!e){const[n]=await chrome.tabs.query({active:!0,currentWindow:!0});if(!n?.id)return"âŒ No active tab found";e=n.id}const o=(await chrome.scripting.executeScript({target:{tabId:e},func:(n,i)=>{let a=null;if(n){if(a=document.querySelector(n),!a)return{success:!1,error:`Element not found: ${n}`};a.focus()}else if(a=document.activeElement,!a)return{success:!1,error:"No focused element found"};if(a instanceof HTMLInputElement||a instanceof HTMLTextAreaElement)return a.value=i,a.dispatchEvent(new Event("input",{bubbles:!0})),a.dispatchEvent(new Event("change",{bubbles:!0})),{success:!0,tagName:a.tagName};if(a.isContentEditable)return a.textContent=i,a.dispatchEvent(new Event("input",{bubbles:!0})),{success:!0,tagName:"ContentEditable"};for(const l of i)l===`
`?(a.dispatchEvent(new KeyboardEvent("keydown",{key:"Enter",bubbles:!0})),a.dispatchEvent(new KeyboardEvent("keypress",{key:"Enter",bubbles:!0})),a.dispatchEvent(new KeyboardEvent("keyup",{key:"Enter",bubbles:!0}))):(a.dispatchEvent(new KeyboardEvent("keydown",{key:l,bubbles:!0})),a.dispatchEvent(new KeyboardEvent("keypress",{key:l,bubbles:!0})),a.dispatchEvent(new KeyboardEvent("keyup",{key:l,bubbles:!0})));return{success:!0,tagName:a.tagName}},args:[t.selector,t.text]}))[0]?.result;return o?.success?`âœ… Typed "${t.text.length>50?t.text.slice(0,50)+"...":t.text}" into ${t.selector||"focused element"} (${o.tagName}) in tab (ID: ${e})`:`âŒ ${o?.error||"Type failed"}`}catch(e){return`âŒ Failed to type: ${e.message}`}}const waitTool={name:"wait",description:"Wait for a specified amount of time (useful for observing page changes after actions)",parameters:{type:"object",properties:{seconds:{type:"number",description:"Number of seconds to wait (0.5 to 10)"}},required:["seconds"]}};async function wait(t){const e=Math.max(.5,Math.min(10,t.seconds));return await new Promise(s=>setTimeout(s,e*1e3)),`âœ… Waited for ${e} seconds`}const doneTool={name:"done",description:"Mark the task as completed and return the final result",parameters:{type:"object",properties:{result:{type:"string",description:"The final result or summary of the task"}},required:["result"]}};async function done(t){return`âœ… Task completed: ${t.result}`}const allTools=[openTabTool,activeTabTool,closeTabTool,reloadTabTool,scrollPageTool,clickTool,keydownTool,waitTool,doneTool],toolExecutors={open_tab:openTab,active_tab:activeTab,close_tab:closeTab,reload_tab:reloadTab,scroll_page:scrollPage,click,keydown,wait,done};class BrowserAgent{config;llm;messages=[];steps=[];totalTokens=0;currentStep=0;constructor(e){this.config={maxSteps:20,systemPrompt:this.getDefaultSystemPrompt(),...e},this.llm=new LLMClient(e),this.messages.push(LLMClient.createTextMessage("system",this.config.systemPrompt))}async execute(e){console.log(chalk.magenta.bold(`
ðŸ¤– Agent started task: "${e}"
`)),this.messages.push(LLMClient.createTextMessage("user",`Task: ${e}

Please complete this task step by step. Use the provided tools to interact with the browser.`));try{for(;this.currentStep<this.config.maxSteps;){this.currentStep++,console.log(chalk.cyan.bold(`
ðŸ“ Step ${this.currentStep}/${this.config.maxSteps}
`));const s=await this.collectContext(),o=this.buildContextMessage(s),r=[...this.messages,o],n=await this.llm.chat(r,allTools,"auto"),i={stepNumber:this.currentStep,timestamp:Date.now(),context:s,llmRequest:{messages:r,tools:allTools},llmResponse:{content:n.message.content||void 0,toolCalls:n.message.tool_calls?.map(a=>({id:a.id,name:a.function.name,arguments:JSON.parse(a.function.arguments)}))},usage:n.usage};if(n.usage&&(this.totalTokens+=n.usage.total_tokens),this.messages.push({role:"assistant",content:n.message.content||"",tool_calls:n.message.tool_calls}),n.message.tool_calls){console.log(chalk.yellow(`   ðŸ”§ Executing ${n.message.tool_calls.length} tool(s)...
`)),i.toolResults=[];for(const a of n.message.tool_calls){const l=a.function.name,c=JSON.parse(a.function.arguments);console.log(chalk.blue(`      â†’ ${l}(${JSON.stringify(c)})`));const p=toolExecutors[l];if(!p){const u=`âŒ Tool not found: ${l}`;console.log(chalk.red(`      ${u}`)),i.toolResults.push({toolCallId:a.id,toolName:l,result:u}),this.messages.push(LLMClient.createToolMessage(a.id,l,u));continue}try{const u=await p(c);if(console.log(chalk.green(`      ${u}`)),i.toolResults.push({toolCallId:a.id,toolName:l,result:u}),this.messages.push(LLMClient.createToolMessage(a.id,l,u)),l==="done")return this.steps.push(i),{success:!0,finalResult:c.result,steps:this.steps,totalSteps:this.currentStep,totalTokens:this.totalTokens}}catch(u){const d=`âŒ Tool execution error: ${u.message}`;console.log(chalk.red(`      ${d}`)),i.toolResults.push({toolCallId:a.id,toolName:l,result:d}),this.messages.push(LLMClient.createToolMessage(a.id,l,d))}}}else n.message.content&&console.log(chalk.yellow(`   ðŸ’¬ Assistant: ${n.message.content}`));this.steps.push(i)}return{success:!1,error:`Reached maximum steps (${this.config.maxSteps})`,steps:this.steps,totalSteps:this.currentStep,totalTokens:this.totalTokens}}catch(s){return console.error(chalk.red.bold(`
âŒ Agent error: ${s.message}
`)),{success:!1,error:s.message,steps:this.steps,totalSteps:this.currentStep,totalTokens:this.totalTokens}}}async collectContext(){const s=(await chrome.tabs.query({})).map(n=>({id:n.id,title:n.title||"Untitled",url:n.url||"about:blank",active:n.active,windowId:n.windowId})),[o]=await chrome.tabs.query({active:!0,currentWindow:!0});if(!o||!o.id)throw new Error("No active tab found");const r=await chrome.tabs.captureVisibleTab(o.windowId,{format:"png"});return{tabs:s,activeTab:{id:o.id,title:o.title||"Untitled",url:o.url||"about:blank",active:!0,windowId:o.windowId},screenshot:r}}buildContextMessage(e){const s=e.tabs.map(r=>`- [${r.id}] ${r.title}${r.active?" (ACTIVE)":""}
  URL: ${r.url}`).join(`
`),o=`
=== CURRENT BROWSER STATE ===

Active Tab: [${e.activeTab.id}] ${e.activeTab.title}
URL: ${e.activeTab.url}

All Tabs (${e.tabs.length} total):
${s}

=== SCREENSHOT ===
The screenshot below shows the current state of the active tab.
Please analyze it carefully before deciding your next action.
`;return LLMClient.createVisionMessage(o,e.screenshot)}getDefaultSystemPrompt(){return`You are a browser automation agent. Your goal is to help users complete tasks by controlling browser tabs.

You have access to the following tools:
- open_tab: Open a new tab with a URL
- active_tab: Switch to a specific tab
- close_tab: Close a tab
- reload_tab: Reload a tab
- scroll_page: Scroll the page up/down/top/bottom
- click: Click an element using CSS selector
- keydown: Type text into an input field
- wait: Wait for a specified time
- done: Mark the task as completed

On each step, you will receive:
1. A list of all open tabs with their IDs, titles, and URLs
2. Information about the currently active tab
3. A screenshot of the active tab

Think step by step:
1. Analyze the current state (tabs and screenshot)
2. Decide what action to take next
3. Use the appropriate tool
4. After each action, observe the result and plan the next step

Important guidelines:
- Use CSS selectors carefully (inspect the page structure from the screenshot)
- Wait after actions that trigger page changes (use the wait tool)
- If you're not sure about a selector, try to scroll and explore the page first
- When the task is complete, call the 'done' tool with a summary

Always be precise and efficient. Complete the task in as few steps as possible.`}getHistory(){return this.steps}getTotalTokens(){return this.totalTokens}}const runningAgents=new Map;function generateUUID(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,function(t){const e=Math.random()*16|0;return(t==="x"?e:e&3|8).toString(16)})}function logMessage(t,e,s){const o=new Date().toLocaleTimeString(),r=t==="incoming"?"ðŸ“¥":"ðŸ“¤",n=t==="incoming"?chalk.cyan:chalk.green;console.log(n.bold(`
${r} [${o}] ${t.toUpperCase()}`)),console.log(chalk.yellow(`   Type: ${e}`)),s&&console.log(chalk.gray("   Data:"),s)}const authenticatedSessions=new Map;let apiKey=generateUUID();console.log("Generated new API key:",apiKey);const definition=defineBackground(()=>{console.log(chalk.magenta.bold(`
ðŸš€ Background service worker started`)),console.log(chalk.yellow(`   API Key: ${apiKey}
`)),chrome.tabs.onRemoved.addListener(t=>{for(const[e,s]of authenticatedSessions.entries())s.tabId===t&&(authenticatedSessions.delete(e),console.log(chalk.red(`
ðŸ—‘ï¸  Tab ${t} closed, cleared session ${e}
`)))}),chrome.runtime.onMessage.addListener((message,sender,sendResponse)=>{const handleMessage=async()=>{try{if(logMessage("incoming",message.type,{sessionId:message.sessionId,tabId:sender.tab?.id,payload:message.payload}),message.type==="GET_API_KEY")return{success:!0,data:apiKey};if(message.type==="REFRESH_API_KEY")return apiKey=generateUUID(),authenticatedSessions.clear(),console.log(chalk.magenta.bold(`
ðŸ”„ Refreshed API key: ${apiKey}`)),console.log(chalk.red(`   Cleared ${authenticatedSessions.size} sessions
`)),{success:!0,data:apiKey};if(message.type==="LINK"){const{key:t}=message.payload,{sessionId:e}=message,s=sender.tab?.id;return s?e?t===apiKey?(authenticatedSessions.set(e,{key:t,tabId:s,timestamp:Date.now()}),console.log(chalk.green.bold(`
âœ… Session authenticated: ${e.substring(0,12)}...`)),console.log(chalk.gray(`   Tab ID: ${s}
`)),{success:!0,data:{authenticated:!0,sessionId:e}}):{success:!1,error:"Invalid key"}:{success:!1,error:"No session ID"}:{success:!1,error:"No tab ID"}}const{sessionId}=message;if(!sessionId)return{success:!1,error:"No session ID"};const session=authenticatedSessions.get(sessionId);if(!session||session.key!==apiKey)return{success:!1,error:"Not authenticated. Call link(key) first."};if(message.type==="GET_TABS")return{success:!0,data:(await chrome.tabs.query({})).map(e=>({id:e.id,title:e.title,url:e.url,active:e.active,windowId:e.windowId}))};if(message.type==="EXECUTE_SCRIPT"){const{tabId,code}=message.payload;if(!tabId||!code)return{success:!1,error:"Missing tabId or code"};const results=await chrome.scripting.executeScript({target:{tabId},world:"MAIN",func:codeString=>eval(codeString),args:[code]});return{success:!0,data:results[0]?.result}}if(message.type==="OPEN_TAB"){const{url:t}=message.payload;if(!t)return{success:!1,error:"Missing url"};const e=await chrome.tabs.create({url:t});return{success:!0,data:{id:e.id,title:e.title,url:e.url,active:e.active,windowId:e.windowId}}}if(message.type==="CLOSE_TAB"){const{tabId:t}=message.payload;return t?(await chrome.tabs.remove(t),{success:!0,data:{tabId:t,closed:!0}}):{success:!1,error:"Missing tabId"}}if(message.type==="AGENT_START"){const{agentId:t,task:e,config:s}=message.payload;if(!t||!e||!s)return{success:!1,error:"Missing agentId, task, or config"};if(runningAgents.has(t))return{success:!1,error:`Agent ${t} is already running`};console.log(chalk.magenta.bold(`
ðŸ¤– Starting agent ${t}...
`));try{const o=new BrowserAgent(s);return runningAgents.set(t,o),o.execute(e).then(r=>{console.log(chalk.green.bold(`
âœ… Agent ${t} completed
`)),console.log(chalk.gray("   Result:"),r),runningAgents.delete(t)}).catch(r=>{console.error(chalk.red.bold(`
âŒ Agent ${t} error: ${r.message}
`)),runningAgents.delete(t)}),{success:!0,data:{agentId:t,status:"started"}}}catch(o){return{success:!1,error:o.message}}}if(message.type==="AGENT_STATUS"){const{agentId:t}=message.payload;if(!t)return{success:!1,error:"Missing agentId"};const e=runningAgents.get(t);return e?{success:!0,data:{agentId:t,status:"running",running:!0,steps:e.getHistory().length,totalTokens:e.getTotalTokens()}}:{success:!0,data:{agentId:t,status:"not_found",running:!1}}}if(message.type==="AGENT_HISTORY"){const{agentId:t}=message.payload;if(!t)return{success:!1,error:"Missing agentId"};const e=runningAgents.get(t);return e?{success:!0,data:{agentId:t,history:e.getHistory(),totalTokens:e.getTotalTokens()}}:{success:!1,error:`Agent ${t} not found`}}if(message.type==="AGENT_STOP"){const{agentId:t}=message.payload;return t?(runningAgents.delete(t),{success:!0,data:{agentId:t,status:"stopped"}}):{success:!1,error:"Missing agentId"}}return{success:!1,error:"Unknown message type"}}catch(t){return console.log(chalk.red.bold(`
âŒ Error processing message:`),t),{success:!1,error:t instanceof Error?t.message:String(t)}}};return handleMessage().then(t=>{logMessage("outgoing",message.type,{success:t.success,data:t.data,error:t.error}),sendResponse(t)}),!0})});function initPlugins(){}globalThis.browser?.runtime?.id?globalThis.browser:globalThis.chrome;function print(t,...e){}const logger={debug:(...t)=>print(console.debug,...t),log:(...t)=>print(console.log,...t),warn:(...t)=>print(console.warn,...t),error:(...t)=>print(console.error,...t)};let result;try{result=definition.main(),result instanceof Promise&&console.warn("The background's main() function return a promise, but it must be synchronous")}catch(t){throw logger.error("The background crashed on startup!"),t}const result$1=result;return result$1})();
